"""
Export utilities for PromptCraft-Hybrid interface.

This module provides functions for exporting content in various formats
with comprehensive metadata including model attribution, file sources,
and session information.
"""

import json
import logging
from datetime import timezone, datetime
from typing import Any

logger = logging.getLogger(__name__)


class ExportUtils:
    """
    Utility class for exporting content with metadata across all journeys.

    Features:
    - Multiple export formats (text, markdown, JSON)
    - Model attribution and cost tracking
    - File source attribution
    - Session metadata inclusion
    - Code snippet extraction and formatting
    """

    def __init__(self) -> None:
        self.export_formats = ["text", "markdown", "json"]

    def export_journey1_content(
        self,
        enhanced_prompt: str,
        create_breakdown: dict[str, str],
        model_info: dict[str, Any],
        file_sources: list[dict[str, Any]],
        session_data: dict[str, Any],
        format_type: str = "markdown",
    ) -> str:
        """
        Export Journey 1 content with full metadata.

        Args:
            enhanced_prompt: The enhanced prompt content
            create_breakdown: C.R.E.A.T.E. framework breakdown
            model_info: Model attribution information
            file_sources: List of source files used
            session_data: Session information
            format_type: Export format (text, markdown, json)

        Returns:
            Formatted export content
        """
        timestamp = datetime.now(timezone.utc).isoformat()

        if format_type == "json":
            return self._export_as_json(
                {
                    "journey": "Journey 1: Smart Templates",
                    "timestamp": timestamp,
                    "enhanced_prompt": enhanced_prompt,
                    "create_breakdown": create_breakdown,
                    "model_info": model_info,
                    "file_sources": file_sources,
                    "session_data": session_data,
                },
            )

        if format_type == "markdown":
            return self._export_as_markdown_j1(
                enhanced_prompt,
                create_breakdown,
                model_info,
                file_sources,
                session_data,
                timestamp,
            )

        # text format
        return self._export_as_text_j1(
            enhanced_prompt,
            create_breakdown,
            model_info,
            file_sources,
            session_data,
            timestamp,
        )

    def _export_as_markdown_j1(
        self,
        enhanced_prompt: str,
        create_breakdown: dict[str, str],
        model_info: dict[str, Any],
        file_sources: list[dict[str, Any]],
        session_data: dict[str, Any],
        timestamp: str,
    ) -> str:
        """Export Journey 1 content as markdown."""

        # Build file sources section
        file_sources_md = ""
        if file_sources:
            file_sources_md = "\\n## ðŸ“„ Source Files\\n\\n"
            for file_info in file_sources:
                file_sources_md += f"- **{file_info.get('name', 'Unknown')}** ({file_info.get('type', 'unknown')})"
                if file_info.get("size"):
                    size_mb = file_info["size"] / (1024 * 1024)
                    file_sources_md += f" - {size_mb:.1f}MB"
                file_sources_md += "\\n"

        # Build C.R.E.A.T.E. breakdown with safe key access
        create_md = """
## ðŸ“‹ C.R.E.A.T.E. Framework Breakdown

### Context
{context}

### Request
{request}

### Examples
{examples}

### Augmentations
{augmentations}

### Tone & Format
{tone_format}

### Evaluation
{evaluation}
""".format(
            context=create_breakdown.get("context", "N/A"),
            request=create_breakdown.get("request", "N/A"),
            examples=create_breakdown.get("examples", "N/A"),
            augmentations=create_breakdown.get("augmentations", "N/A"),
            tone_format=create_breakdown.get("tone_format", "N/A"),
            evaluation=create_breakdown.get("evaluation", "N/A"),
        )

        return f"""# Enhanced Prompt Export
*Generated by PromptCraft-Hybrid*

**Export Date:** {timestamp}
**Journey:** Journey 1: Smart Templates
**Model:** {model_info.get('model', 'Unknown')}
**Response Time:** {model_info.get('response_time', 'N/A')}s
**Cost:** ${model_info.get('cost', 0.0):.4f}

---

## âœ¨ Enhanced Prompt

{enhanced_prompt}

{create_md}

{file_sources_md}

---

## ðŸ” Session Information

- **Session Cost:** ${session_data.get('total_cost', 0.0):.4f}
- **Requests:** {session_data.get('request_count', 0)}
- **Average Response Time:** {session_data.get('avg_response_time', 0.0):.2f}s

---

*Exported from PromptCraft-Hybrid | Generated with AI assistance*
"""

    def _export_as_text_j1(
        self,
        enhanced_prompt: str,
        create_breakdown: dict[str, str],
        model_info: dict[str, Any],
        file_sources: list[dict[str, Any]],
        session_data: dict[str, Any],
        timestamp: str,
    ) -> str:
        """Export Journey 1 content as plain text."""

        file_sources_txt = ""
        if file_sources:
            file_sources_txt = "\\n\\nSOURCE FILES USED:\\n"
            for file_info in file_sources:
                file_sources_txt += f"- {file_info.get('name', 'Unknown')} ({file_info.get('type', 'unknown')})\\n"

        return f"""ENHANCED PROMPT EXPORT
Generated by PromptCraft-Hybrid

Export Date: {timestamp}
Journey: Journey 1: Smart Templates
Model: {model_info.get('model', 'Unknown')}
Response Time: {model_info.get('response_time', 'N/A')}s
Cost: ${model_info.get('cost', 0.0):.4f}

{"="*50}

ENHANCED PROMPT:

{enhanced_prompt}

{"="*50}

C.R.E.A.T.E. FRAMEWORK BREAKDOWN:

CONTEXT:
{create_breakdown.get('context', 'N/A')}

REQUEST:
{create_breakdown.get('request', 'N/A')}

EXAMPLES:
{create_breakdown.get('examples', 'N/A')}

AUGMENTATIONS:
{create_breakdown.get('augmentations', 'N/A')}

TONE & FORMAT:
{create_breakdown.get('tone_format', 'N/A')}

EVALUATION:
{create_breakdown.get('evaluation', 'N/A')}

{file_sources_txt}

{"="*50}

SESSION INFORMATION:
- Session Cost: ${session_data.get('total_cost', 0.0):.4f}
- Requests: {session_data.get('request_count', 0)}
- Average Response Time: {session_data.get('avg_response_time', 0.0):.2f}s

Exported from PromptCraft-Hybrid | Generated with AI assistance
"""

    def _export_as_json(self, data: dict[str, Any]) -> str:
        """Export content as JSON with proper formatting."""
        try:
            return json.dumps(data, indent=2, ensure_ascii=False)
        except Exception as e:
            logger.error("Error exporting as JSON: %s", e)
            return json.dumps({"error": f"Export failed: {e}"}, indent=2)

    def extract_code_blocks(self, content: str) -> list[dict[str, Any]]:
        """
        Extract code blocks from content with enhanced detection.

        Args:
            content: Content to extract code blocks from

        Returns:
            List of code block dictionaries with language and content
        """
        # Use string operations instead of regex to prevent ReDoS attacks completely
        # Find all ``` positions and pair them as opening/closing delimiters
        positions = []
        start = 0
        while True:
            pos = content.find("```", start)
            if pos == -1:
                break
            positions.append(pos)
            start = pos + 3

        matches = []
        # Process pairs of positions (opening and closing delimiters)
        for i in range(0, len(positions) - 1, 2):
            if i + 1 < len(positions):
                start_pos = positions[i] + 3  # After opening ```
                end_pos = positions[i + 1]  # Before closing ```
                block_content = content[start_pos:end_pos]

                lines = block_content.strip().split("\n", 1)

                # First line might contain language, rest is code
                if len(lines) > 1:
                    potential_lang = lines[0].strip()
                    code_content = lines[1]
                    # Simple validation: language should be alphanumeric/dash only
                    if potential_lang and all(c.isalnum() or c in "-_" for c in potential_lang):
                        matches.append((potential_lang, code_content))
                    else:
                        matches.append(("", block_content.strip()))
                else:
                    matches.append(("", block_content.strip()))

        code_blocks = []
        for i, (language, code) in enumerate(matches):
            code_content = code.strip()
            lines = code_content.split("\n")

            # Enhanced language detection
            detected_language = language or self._detect_language(code_content)

            # Extract any inline comments or documentation
            comments = self._extract_comments(code_content, detected_language)

            code_blocks.append(
                {
                    "id": i + 1,
                    "language": detected_language,
                    "content": code_content,
                    "line_count": len(lines),
                    "char_count": len(code_content),
                    "comments": comments,
                    "has_functions": self._has_functions(code_content, detected_language),
                    "complexity": self._assess_complexity(code_content),
                    "preview": lines[0][:50] + "..." if lines else "",
                },
            )

        return code_blocks

    def _detect_language(self, code: str) -> str:  # noqa: PLR0911
        """Detect programming language from code content."""
        # Simple language detection using string operations (safer than regex)
        code_lower = code.lower()

        # Check for common keywords with simple string operations
        if "def " in code and "(" in code:
            return "python"
        if "function " in code and "(" in code:
            return "javascript"
        if "class " in code and "{" in code:
            return "java"
        if "#include" in code:
            return "cpp"
        if "select " in code_lower and "from " in code_lower:
            return "sql"
        if any(tag in code_lower for tag in ["<html", "<div", "<p>"]):
            return "html"
        if code.strip().startswith("{") and ":" in code:
            return "json"
        if "---" in code:
            return "yaml"
        return "text"

    def _extract_comments(self, code: str, language: str) -> list[str]:  # noqa: PLR0912
        """Extract comments from code based on language."""
        comments = []

        if language == "python":
            # Python comments - use simple line-by-line parsing
            for line in code.split("\n"):
                if "#" in line:
                    comment_part = line.split("#", 1)[1].strip()
                    if comment_part:
                        comments.append(comment_part)

            # Simple docstring detection
            if '"""' in code:
                parts = code.split('"""')
                for i in range(1, len(parts), 2):  # Every other part is a docstring
                    if parts[i].strip():
                        comments.append(parts[i].strip())

        elif language in ["javascript", "java", "cpp"]:
            # C-style comments - use simple line-by-line parsing
            for line in code.split("\n"):
                if "//" in line:
                    comment_part = line.split("//", 1)[1].strip()
                    if comment_part:
                        comments.append(comment_part)

            # Simple block comment detection
            if "/*" in code and "*/" in code:
                parts = code.split("/*")
                for part in parts[1:]:  # Skip first part (before first comment)
                    if "*/" in part:
                        comment_content = part.split("*/", 1)[0].strip()
                        if comment_content:
                            comments.append(comment_content)

        elif language == "html":
            # HTML comments - use simple string operations
            if "<!--" in code and "-->" in code:
                parts = code.split("<!--")
                for part in parts[1:]:  # Skip first part (before first comment)
                    if "-->" in part:
                        comment_content = part.split("-->", 1)[0].strip()
                        if comment_content:
                            comments.append(comment_content)

        return [comment.strip() for comment in comments if comment.strip()]

    def _has_functions(self, code: str, language: str) -> bool:
        """Check if code contains function definitions."""
        if language == "python":
            # Simple check for Python function definitions
            return "def " in code and "(" in code
        if language == "javascript":
            # Simple check for JavaScript function definitions
            return "function " in code and "(" in code
        if language in ["java", "cpp"]:
            # Simple check for Java/C++ function definitions
            return "(" in code and ")" in code and "{" in code
        return False

    def _assess_complexity(self, code: str) -> str:
        """Assess code complexity based on lines and complexity indicators."""
        lines = len(code.split("\n"))

        # Count complexity indicators
        complexity_indicators = 0

        # Check for control structures
        if "if " in code or "elif " in code or "else:" in code:
            complexity_indicators += 1
        if "for " in code or "while " in code:
            complexity_indicators += 1
        if "try:" in code or "except:" in code or "finally:" in code:
            complexity_indicators += 1
        if "def " in code or "class " in code:
            complexity_indicators += 1
        if "import " in code:
            complexity_indicators += 1

        # Complexity thresholds
        simple_line_threshold = 10
        complex_line_threshold = 20
        max_simple_complexity = 1
        max_moderate_complexity = 3

        # Assess based on lines and complexity indicators
        if lines < simple_line_threshold and complexity_indicators <= max_simple_complexity:
            return "simple"
        if lines >= complex_line_threshold or complexity_indicators > max_moderate_complexity:
            return "complex"
        return "moderate"

    def format_code_blocks_for_export(self, code_blocks: list[dict[str, Any]]) -> str:
        """
        Format code blocks for export with enhanced metadata.

        Args:
            code_blocks: List of code block dictionaries

        Returns:
            Formatted code blocks for export
        """
        if not code_blocks:
            return "No code blocks found."

        # Summary header
        total_lines = sum(block.get("line_count", 0) for block in code_blocks)
        # Preserve order while removing duplicates
        seen = set()
        languages = []
        for block in code_blocks:
            lang = block.get("language", "text")
            if lang not in seen:
                languages.append(lang)
                seen.add(lang)

        export_content = f"""CODE BLOCKS EXPORT
==================
â€¢ Total blocks: {len(code_blocks)}
â€¢ Total lines: {total_lines}
â€¢ Languages: {', '.join(languages)}
â€¢ Extracted: {len([b for b in code_blocks if b.get('has_functions', False)])} blocks with functions

"""

        for block in code_blocks:
            # Enhanced block header
            complexity = block.get("complexity", "unknown")
            has_functions = block.get("has_functions", False)
            comments_count = len(block.get("comments", []))

            export_content += f"{'='*60}\n"
            export_content += f"ðŸ“„ Block {block['id']}: {block.get('language', 'text').upper()}\n"
            export_content += f"{'='*60}\n"
            export_content += f"â€¢ Lines: {block.get('line_count', 0)}\n"
            export_content += f"â€¢ Characters: {block.get('char_count', 0)}\n"
            export_content += f"â€¢ Complexity: {complexity}\n"
            export_content += f"â€¢ Functions: {'Yes' if has_functions else 'No'}\n"
            export_content += f"â€¢ Comments: {comments_count}\n"

            if block.get("preview"):
                export_content += f"â€¢ Preview: {block['preview']}\n"

            export_content += f"\n{'-'*40}\n"
            export_content += "CODE:\n"
            export_content += f"{'-'*40}\n"
            export_content += block["content"]
            export_content += "\n\n"

            # Include comments if available
            if block.get("comments"):
                export_content += f"{'-'*40}\n"
                export_content += "COMMENTS:\n"
                export_content += f"{'-'*40}\n"
                for comment in block["comments"]:
                    export_content += f"â€¢ {comment}\n"
                export_content += "\n"

        return export_content

    def copy_code_as_markdown(self, code_blocks: list[dict[str, Any]]) -> str:
        """
        Format code blocks as markdown for copying with enhanced metadata.

        Args:
            code_blocks: List of code block dictionaries

        Returns:
            Markdown formatted code blocks
        """
        if not code_blocks:
            return "No code blocks found."

        # Summary header
        total_lines = sum(block.get("line_count", 0) for block in code_blocks)
        # Preserve order while removing duplicates
        seen = set()
        languages = []
        for block in code_blocks:
            lang = block.get("language", "text")
            if lang not in seen:
                languages.append(lang)
                seen.add(lang)

        markdown_content = f"""# Code Blocks Export

**Summary:**
- Total blocks: {len(code_blocks)}
- Total lines: {total_lines}
- Languages: {', '.join(languages)}

---

"""

        for block in code_blocks:
            # Enhanced block header with metadata
            complexity = block.get("complexity", "unknown")
            has_functions = block.get("has_functions", False)
            comments_count = len(block.get("comments", []))

            markdown_content += f"## Block {block['id']}: {block.get('language', 'text').title()}\n\n"

            # Metadata table
            markdown_content += f"""**Metadata:**
- Lines: {block.get('line_count', 0)}
- Characters: {block.get('char_count', 0)}
- Complexity: {complexity}
- Contains functions: {'Yes' if has_functions else 'No'}
- Comments: {comments_count}

"""

            # Add comments if available
            if block.get("comments"):
                markdown_content += "**Comments:**\n"
                for comment in block["comments"]:
                    markdown_content += f"- {comment}\n"
                markdown_content += "\n"

            # Code block
            markdown_content += f"```{block.get('language', 'text')}\n{block['content']}\n```\n\n"

            # Separator
            markdown_content += "---\n\n"

        return markdown_content.strip()

    def prepare_download_file(self, content: str, filename: str, format_type: str = "txt") -> str:
        """
        Prepare content for download.

        Args:
            content: Content to prepare for download
            filename: Base filename (without extension)
            format_type: File format (txt, md, json)

        Returns:
            Formatted filename for download
        """
        timestamp = datetime.now(timezone.utc).strftime("%Y%m%d_%H%M%S")
        clean_filename = "".join(c for c in filename if c.isalnum() or c in (" ", "-", "_")).rstrip()

        return f"{clean_filename}_{timestamp}.{format_type}"
